Пример 1:

(3) Возникла ошибка компиляции из-за того, что функция hello не была определена в месте, где она была вызвана (например, в main). Даже если бы она была определена, линкер не мог бы связать имя функции с конкретным адресом, поскольку она могла бы быть определена в другом файле.
Пример 2:

(4) Произошла ошибка "duplicate symbol", потому что имена функций попали в таблицу символов (symbol table) после компиляции, и два объектных файла имели свои собственные символы для функции. Линкер отбрасывает дубликаты.

(6) Ошибка "функция не определена" возникла на этапе линковки, так как символ (имя функции) существует, но не имеет конкретного адреса для ссылки.

(8) Ошибка также возникла на этапе линковки из-за модификатора static. Функция hello определена только в f.cpp и, следовательно, не доступна извне этого файла. Она объявлена, но не определена.

(10) Работает, потому что функция hello определена и объявлена в main.cpp, что позволяет линкеру знать, куда обращаться при вызове hello.

(11) В финальном исполняемом файле будет две копии тела функции hello, по одной для каждого файла компиляции. Это происходит из-за того, что каждый исходный файл компилируется независимо, и линкер объединяет их вместе, сохраняя каждую копию.

STACK, HEAP, STATIC MEMORY:

Глобальная переменная типа static в отличие от глобальной видна только внутри файла, в котором она объявлена. Она хранится в сегменте данных и имеет тот же срок жизни, что и программа.

Чтобы сделать второй пример эквивалентным первому, можно добавить модификатор static к глобальной переменной. Это сделает переменную недоступной для импорта из другого файла, поскольку она будет иметь локальную область видимости внутри файла. Таким образом, глобальная переменная a из второго примера будет эквивалентна глобальной переменной a с модификатором static из первого примера, что предотвратит её использование за пределами файла, в котором она была объявлена.






